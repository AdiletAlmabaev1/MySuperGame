<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>POCKET DOTA 2 P2P</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --rad: #4CAF50; --dire: #F44336; --gold: #FFD700; --mana: #00B0FF; --bg: #0d1117; }
        * { box-sizing: border-box; touch-action: none; user-select: none; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body { 
            margin: 0; overflow: hidden; background: #000; font-family: 'Roboto', sans-serif; 
            color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
        }

        /* UI SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(#1e2228, #000);
            z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; display: none !important; }

        h1 { font-family: 'Cinzel', serif; font-size: 3rem; color: #ccc; text-shadow: 0 0 10px #aa0000; margin-bottom: 0.5rem; letter-spacing: 5px; }
        
        .box {
            background: rgba(20,20,30, 0.9); padding: 30px; border: 1px solid #444; 
            box-shadow: 0 0 20px rgba(0,0,0,0.8); border-radius: 4px; max-width: 500px; width: 90%; text-align: center;
        }

        button {
            background: linear-gradient(180deg, #3a4b5d, #252e38); color: #fff; border: 1px solid #666;
            padding: 15px 30px; margin: 10px; font-size: 1.1rem; font-family: 'Cinzel', serif; cursor: pointer; width: 100%;
            transition: 0.2s; box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
        }
        button:hover { filter: brightness(1.2); border-color: #888; }
        button:active { transform: translateY(2px); }
        input { width: 100%; padding: 15px; background: #111; border: 1px solid #444; color: #fff; margin-bottom: 10px; font-family: monospace; font-size: 1.2rem; text-align: center; }

        /* GAME HUD */
        #game-view { position: relative; width: 100%; height: 100%; overflow: hidden; cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; background: #0b0f0a; }

        .top-bar {
            position: absolute; top: 0; width: 100%; height: 50px; background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: center; padding: 0 20px; font-family: 'Cinzel';
        }
        .hero-portrait { width: 60px; height: 60px; border: 2px solid #555; background: #222; margin-top: 10px; display: flex; align-items: center; justify-content: center; font-size: 2rem; position: relative; }
        .score-board { font-size: 1.5rem; font-weight: bold; letter-spacing: 2px; }
        .clock { color: #fff; font-weight: bold; }
        
        .team-rad { border-color: var(--rad); box-shadow: 0 0 10px var(--rad); }
        .team-dire { border-color: var(--dire); box-shadow: 0 0 10px var(--dire); }

        /* SKILLS PANEL */
        .controls-layer { pointer-events: none; position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: flex-end; padding-bottom: 20px;}
        
        /* Mobile Joystick */
        #joystick-zone { position: absolute; bottom: 30px; left: 30px; width: 150px; height: 150px; pointer-events: auto; }
        .joy-base { width: 100%; height: 100%; background: rgba(255,255,255,0.05); border: 2px dashed rgba(255,255,255,0.1); border-radius: 50%; display: flex; justify-content: center; align-items: center; }
        .joy-stick { width: 40%; height: 40%; background: rgba(255,255,255,0.2); border-radius: 50%; box-shadow: 0 0 15px #000; }

        /* Skill Bar */
        .skill-dock {
            pointer-events: auto; display: flex; gap: 15px; margin: 0 auto; background: rgba(0,0,0,0.6); 
            padding: 10px 20px; border-radius: 10px; backdrop-filter: blur(5px); border: 1px solid #333;
        }
        .skill-btn {
            width: 70px; height: 70px; background: #222; border: 2px solid #555; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: 0.1s;
        }
        .skill-btn:active { transform: scale(0.95); border-color: #fff; }
        .skill-btn.active-skill { border-color: var(--gold); box-shadow: 0 0 10px var(--gold); }
        .skill-key { position: absolute; top: 2px; left: 4px; font-size: 0.7rem; color: #888; font-weight: bold; }
        .skill-icon { font-size: 1.8rem; }
        .cd-overlay { 
            position: absolute; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; 
            font-size: 1.2rem; font-weight: bold; color: #fff; opacity: 0; transition: 0s;
        }
        .mana-cost { position: absolute; bottom: 2px; right: 4px; font-size: 0.8rem; color: var(--mana); text-shadow: 1px 1px 0 #000; }
        
        .big-btn { width: 90px; height: 90px; border-color: var(--dire); } /* Ult */

        /* Player Stats Overlay */
        .stats-bar {
            width: 100%; text-align: center; position: absolute; bottom: 100px;
            text-shadow: 1px 1px 2px #000; font-size: 0.9rem;
            display: flex; justify-content: center; gap: 15px;
        }
        .stat-item { display: flex; align-items: center; gap: 5px; background: rgba(0,0,0,0.5); padding: 4px 10px; border-radius: 20px; }

        /* Effects */
        #logger { position: absolute; top: 60px; left: 10px; color: #ffff00; font-family: monospace; font-size: 0.8rem; width: 300px; height: 100px; overflow: hidden; pointer-events: none; opacity: 0.7; }
        
        @media (min-width: 800px) {
            #joystick-zone { display: none; }
            .skill-dock { position: absolute; bottom: 20px; right: 50%; transform: translateX(50%); }
        }
    </style>
</head>
<body oncontextmenu="return false;">

<!-- 1. –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ -->
<div id="scr-menu" class="screen">
    <div style="width: 100px; height: 100px; border: 5px solid #a23; background: #111; margin-bottom: 20px; transform: rotate(45deg); display:flex; align-items:center; justify-content:center;">
        <div style="width: 70%; height: 70%; border: 3px solid #ccc; background: #300; transform: rotate(-45deg);"></div>
    </div>
    <h1>DOTA LITE</h1>
    <div class="box">
        <button onclick="Network.host()" style="border-color: #4CAF50">–°–û–ó–î–ê–¢–¨ –ò–ì–†–£ (RADIANT)</button>
        <div style="margin: 10px 0; color: #666">- –∏–ª–∏ -</div>
        <button onclick="UI.toJoin()">–ü–û–î–ö–õ–Æ–ß–ò–¢–¨–°–Ø (DIRE)</button>
    </div>
</div>

<!-- 2. –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï -->
<div id="scr-join" class="screen hidden">
    <h2>–ü–û–ò–°–ö –ò–ì–†–´</h2>
    <div class="box">
        <p>–í–≤–µ–¥–∏—Ç–µ ID –ª–æ–±–±–∏ –æ—Ç –•–æ—Å—Ç–∞:</p>
        <input type="text" id="host-id-input" placeholder="ID –•–æ—Å—Ç–∞...">
        <button onclick="Network.join()">–í–û–ô–¢–ò –í –ë–ò–¢–í–£</button>
        <button onclick="location.reload()" style="background: transparent; border: none; color: #888;">–ù–∞–∑–∞–¥</button>
    </div>
</div>

<!-- 3. –õ–û–ë–ë–ò / –û–ñ–ò–î–ê–ù–ò–ï -->
<div id="scr-lobby" class="screen hidden">
    <h2>–û–ñ–ò–î–ê–ù–ò–ï...</h2>
    <div class="box">
        <p>–¢–≤–æ–π ID –ª–æ–±–±–∏ (—Å–∫–∏–Ω—å –¥—Ä—É–≥—É):</p>
        <input type="text" id="my-id-display" readonly style="color: var(--gold); border-color: var(--gold); cursor: pointer;" onclick="this.select(); document.execCommand('copy');">
        <div id="status-msg" style="color: #4CAF50; margin-top: 15px;">–ñ–¥–µ–º –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...</div>
    </div>
</div>

<!-- 4. –ò–ì–†–û–í–û–ô –ü–†–û–¶–ï–°–° -->
<div id="scr-game" class="screen hidden" style="background: transparent; justify-content: flex-start;">
    <div id="game-view">
        <canvas id="cvs"></canvas>
        <div class="top-bar">
            <div class="hero-portrait team-rad" id="hud-p1">üõ°Ô∏è</div>
            <div class="score-board">
                <span style="color:var(--rad)" id="score-rad">0</span> 
                <span class="clock" id="game-timer">00:00</span>
                <span style="color:var(--dire)" id="score-dire">0</span>
            </div>
            <div class="hero-portrait team-dire" id="hud-p2">üî•</div>
        </div>
        
        <div id="logger">System Init...</div>

        <!-- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ -->
        <div class="controls-layer">
            <div class="stats-bar">
                <div class="stat-item"><span style="color:gold">G:</span> <span id="hud-gold">0</span></div>
                <div class="stat-item"><span style="color:lime">HP:</span> <span id="hud-hp">100%</span></div>
                <div class="stat-item"><span style="color:cyan">LVL:</span> <span id="hud-lvl">1</span></div>
                <div class="stat-item">‚öîÔ∏è <span id="hud-dmg">50</span></div>
            </div>

            <!-- Skills -->
            <div class="skill-dock">
                <!-- Skill 1 -->
                <div class="skill-btn" id="btn-q" onmousedown="Inp.useSkill(0)" ontouchstart="Inp.useSkill(0)">
                    <div class="skill-key">Q</div>
                    <div class="skill-icon" id="icon-q">‚ö°</div>
                    <div class="cd-overlay" id="cd-q">0</div>
                    <div class="mana-cost" id="mc-q">50</div>
                </div>
                <!-- Skill 2 -->
                <div class="skill-btn" id="btn-w" onmousedown="Inp.useSkill(1)" ontouchstart="Inp.useSkill(1)">
                    <div class="skill-key">W</div>
                    <div class="skill-icon" id="icon-w">üõ°Ô∏è</div>
                    <div class="cd-overlay" id="cd-w">0</div>
                    <div class="mana-cost" id="mc-w">80</div>
                </div>
                <!-- Ultimate -->
                <div class="skill-btn big-btn" id="btn-r" onmousedown="Inp.useSkill(2)" ontouchstart="Inp.useSkill(2)">
                    <div class="skill-key">R</div>
                    <div class="skill-icon" id="icon-r">‚òÑÔ∏è</div>
                    <div class="cd-overlay" id="cd-r">0</div>
                    <div class="mana-cost" id="mc-r">150</div>
                </div>
                 <!-- Attack/Hit for Mobile -->
                 <div class="skill-btn big-btn" style="border-color:#fff; background:#422;" id="btn-a" onmousedown="Inp.attack()" ontouchstart="Inp.attack()">
                    <div class="skill-key">SPC</div>
                    <div class="skill-icon">‚öîÔ∏è</div>
                </div>
            </div>
            
            <div id="joystick-zone">
                <div class="joy-base"><div class="joy-stick"></div></div>
            </div>
        </div>
    </div>
    
    <!-- Game Over Screen Overlay -->
    <div id="end-screen" style="position:absolute; inset:0; background:rgba(0,0,0,0.8); display:none; flex-direction:column; align-items:center; justify-content:center;">
        <h1 id="end-title" style="color:gold">VICTORY</h1>
        <button onclick="location.reload()" style="max-width:200px">–í –ú–ï–ù–Æ</button>
    </div>
</div>

<script>
// ================= CORE UTILS =================
const $ = (id) => document.getElementById(id);
const log = (txt) => { const l=$('logger'); l.innerText=txt+"\n"+l.innerText; };
const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≥–µ—Ä–æ–µ–≤
const HEROES = {
    knight: { name: "Omni", hp: 600, maxHp:600, mp:300, maxMp:300, spd: 4, dmg: 45, range: 60, color:'#4CAF50', skills:['üî®','üõ°Ô∏è','üòá'] },
    mage:   { name: "Lina", hp: 450, maxHp:450, mp:400, maxMp:400, spd: 3.8, dmg: 40, range: 180, color:'#F44336', skills:['üî•','üåä','‚ö°'] }
};

const SKILLS_DB = [
    // Knight
    { cost: 60, cd: 6, dmg: 100, range: 150, type:'target', name:'Heal/Nuke' },
    { cost: 80, cd: 12, dmg: 0,   range: 0,   type:'buff',   name:'Repel', duration: 180 },
    { cost: 150,cd: 40, dmg: 0,   range: 400, type:'global', name:'Guardian', duration: 300 },
    // Mage
    { cost: 70, cd: 5,  dmg: 120, range: 300, type:'linear', name:'Slave' },
    { cost: 90, cd: 10, dmg: 80,  range: 250, type:'area',   name:'Stun' },
    { cost: 200,cd: 50, dmg: 400, range: 400, type:'target', name:'Laguna' }
];

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä—ã
const GAME = {
    running: false, width: 0, height: 0,
    role: 'spec', // 'host' –∏–ª–∏ 'client'
    playerId: 0, // 0 = host (radiant), 1 = client (dire)
    lastTick: 0, dt: 0, timer: 0,
    camera: { x:0, y:0 }, // –¥–ª—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ (–∑–¥–µ—Å—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ –∏–≥—Ä–æ–∫–µ)
    
    // –°—É—â–Ω–æ—Å—Ç–∏
    ents: [], 
    fx: [], // —á–∞—Å—Ç–∏—Ü—ã
    projectiles: []
};

// ================= NETWORK (PEERJS) =================
const Network = {
    peer: null, conn: null,
    host: () => {
        UI.show('scr-lobby');
        GAME.role = 'host'; GAME.playerId = 0;
        Network.init();
    },
    join: () => {
        const id = $('host-id-input').value.trim();
        if(!id) return alert("–í–≤–µ–¥–∏—Ç–µ ID!");
        GAME.role = 'client'; GAME.playerId = 1;
        UI.show('scr-lobby');
        Network.init(id);
    },
    init: (connectTo = null) => {
        Network.peer = new Peer({ debug: 1 });
        Network.peer.on('open', (id) => {
            if(GAME.role === 'host') $('my-id-display').value = id;
            if(connectTo) {
                log("Connecting...");
                Network.conn = Network.peer.connect(connectTo);
                Network.setupConn();
            }
        });
        Network.peer.on('connection', (c) => {
            Network.conn = c;
            Network.setupConn();
        });
        Network.peer.on('error', err => log("ERR: "+err));
    },
    setupConn: () => {
        Network.conn.on('open', () => {
            log("Connected!");
            if(GAME.role === 'host') {
                $('status-msg').innerText = "–ò–≥—Ä–æ–∫ –Ω–∞–π–¥–µ–Ω! –ó–∞–ø—É—Å–∫...";
                setTimeout(GameLogic.init, 1000);
            } else {
                $('status-msg').innerText = "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ! –ñ–¥–µ–º —Ö–æ—Å—Ç–∞...";
            }
        });
        Network.conn.on('data', data => {
            if(data.t === 'START') { GameLogic.start(data.seed); }
            if(data.t === 'STATE') { Client.sync(data.s); }
            if(data.t === 'INPUT') { Server.handleInput(1, data.i); } // –¢–æ–ª—å–∫–æ —Ö–æ—Å—Ç –ø–æ–ª—É—á–∞–µ—Ç –∏–Ω–ø—É—Ç –æ—Ç P2
        });
        Network.conn.on('close', () => alert("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ"));
    }
};

// ================= LOGIC & PHYSICS (HOST ONLY) =================
const Server = {
    seed: 0, w: 2000, h: 2000, // –†–∞–∑–º–µ—Ä –∫–∞—Ä—Ç—ã
    t: 0, creepTimer: 0,
    
    spawn: (type, team, x, y, aiMode=null) => {
        const id = Math.random().toString(36).substr(2,9);
        const stats = type === 'hero' ? (team===0 ? HEROES.knight : HEROES.mage) :
                      type === 'creep' ? { hp:150, maxHp:150, dmg:10, spd:2, range:30, bounty:40 } :
                      type === 'tower' ? { hp:1500, maxHp:1500, dmg:40, spd:0, range:250, bounty:200 } :
                      { hp:3000, maxHp:3000, dmg:0, spd:0, range:0, bounty:0 }; // ancient

        GAME.ents.push({
            id, type, team, x, y, 
            hp: stats.hp, maxHp: stats.maxHp || stats.hp,
            dmg: stats.dmg, spd: stats.spd, range: stats.range,
            mp: stats.mp||0, maxMp: stats.maxMp||0,
            skills: stats.skills||[], skillCD: [0,0,0],
            cd: 0, // Attack cooldown
            ai: aiMode, targetId: null,
            lvl: 1, xp: 0, gold: team<2 ? 600 : 0,
            vx: 0, vy: 0, // Velocity
            dead: false
        });
    },

    update: () => {
        Server.t++;
        const ents = GAME.ents;

        // 1. Spawner
        if(Server.t % 1800 === 0) { // –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫ (–ø—Ä–∏ 60fps)
            // Radiants (Team 0) Bottom-Left
            Server.spawn('creep', 0, 200, Server.h - 200, 'lane');
            Server.spawn('creep', 0, 250, Server.h - 150, 'lane');
            Server.spawn('creep', 0, 150, Server.h - 250, 'lane');
            // Dires (Team 1) Top-Right
            Server.spawn('creep', 1, Server.w-200, 200, 'lane');
            Server.spawn('creep', 1, Server.w-250, 150, 'lane');
            Server.spawn('creep', 1, Server.w-150, 250, 'lane');
        }

        // 2. Physics & Logic
        ents.forEach(e => {
            if(e.dead) return;

            // Regen
            if(Server.t%60===0) { 
                if(e.hp < e.maxHp) e.hp += 1;
                if(e.mp && e.mp < e.maxMp) e.mp += 2;
                e.skillCD = e.skillCD.map(c => c > 0 ? c-1 : 0);
                if(e.respawnTimer > 0) e.respawnTimer--;
            }

            // Input Movement (Heroes)
            if(e.type === 'hero') {
                e.x += e.vx * e.spd;
                e.y += e.vy * e.spd;
            } 
            // AI Movement (Creeps)
            else if(e.type === 'creep' && e.ai === 'lane') {
                // –ò–¥–µ–º –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ (—Å —É–≥–ª–∞ –≤ —É–≥–æ–ª)
                let tx = e.team===0 ? Server.w-200 : 200;
                let ty = e.team===0 ? 200 : Server.h-200;
                
                // –ü—Ä–æ—Å—Ç–æ–π AI –∞—Ç–∞–∫–∏: –∏—â–µ–º –≤—Ä–∞–≥–∞ —Ä—è–¥–æ–º
                let enemy = ents.find(x => !x.dead && x.team !== e.team && dist(e,x) < 200);
                if(enemy) {
                    tx = enemy.x; ty = enemy.y;
                    // –ï—Å–ª–∏ –≤ —Ä–µ–Ω–¥–∂–µ –∞—Ç–∞–∫–∏ - —Å—Ç–æ–ø
                    if(dist(e,enemy) < e.range) { tx = e.x; ty = e.y; }
                }

                const angle = Math.atan2(ty - e.y, tx - e.x);
                if(dist(e, {x:tx, y:ty}) > 5) {
                    e.x += Math.cos(angle) * e.spd;
                    e.y += Math.sin(angle) * e.spd;
                }
            }

            // Clamping
            e.x = Math.max(0, Math.min(Server.w, e.x));
            e.y = Math.max(0, Math.min(Server.h, e.y));

            // Auto Attack
            if(e.cd > 0) e.cd--;
            else {
                let target = ents.find(t => !t.dead && t.team !== e.team && dist(e,t) <= e.range + 20); // +20 —Ä–∞–¥–∏—É—Å —Ç–µ–ª–∞
                if(target) {
                    GAME.projectiles.push({
                        x:e.x, y:e.y, tx:target.id, dmg:e.dmg, spd:8, 
                        color: e.team===0 ? '#0f0':'#f00', type:'aa'
                    });
                    e.cd = 60; // 1 atk/sec
                }
            }
        });

        // 3. Projectiles
        for(let i=GAME.projectiles.length-1; i>=0; i--) {
            let p = GAME.projectiles[i];
            let target = ents.find(x => x.id === p.tx);
            if(!target || target.dead) { GAME.projectiles.splice(i,1); continue; }

            let ang = Math.atan2(target.y-p.y, target.x-p.x);
            p.x += Math.cos(ang) * p.spd;
            p.y += Math.sin(ang) * p.spd;

            if(dist(p, target) < 20) {
                target.hp -= p.dmg;
                GAME.fx.push({x:target.x, y:target.y, t:10, txt:`-${p.dmg}`}); // Hit marker
                GAME.projectiles.splice(i,1);

                // Death Logic
                if(target.hp <= 0) {
                    target.dead = true;
                    // Give rewards logic could be complex (find owner of proj), simplifying:
                    // If target is hero, longer respawn. Ancient = GG.
                    if(target.type === 'ancient') {
                        Server.endGame(target.team === 0 ? 'Dire' : 'Radiant');
                    }
                    if(target.type === 'hero') {
                         setTimeout(() => { // RESPAWN
                            target.dead = false; target.hp = target.maxHp; target.mp = target.maxMp;
                            target.x = target.team===0 ? 100 : Server.w-100;
                            target.y = target.team===0 ? Server.h-100 : 100;
                         }, 5000);
                    }
                }
            }
        }
        
        // FX Clean
        GAME.fx = GAME.fx.filter(f => f.t-- > 0);
    },

    handleInput: (pid, inp) => {
        // –ù–∞–π–¥–µ–º –≥–µ—Ä–æ—è –∏–≥—Ä–æ–∫–∞
        const h = GAME.ents.find(e => e.type === 'hero' && e.team === pid);
        if(!h || h.dead) return;
        
        // Move
        if(inp.type === 'move') { h.vx = inp.x; h.vy = inp.y; }
        
        // Attack stop
        if(inp.type === 'atk') { /* Manual attack logic or just move to stop */ }

        // Skills
        if(inp.type === 'skill') {
            const skillIdx = inp.slot;
            // –û–ø—Ä–µ–¥–µ–ª–∏–º –∏–Ω–¥–µ–∫—Å —Å–∫–∏–ª–ª–∞ –≤ –æ–±—â–µ–º –º–∞—Å—Å–∏–≤–µ
            const baseIdx = (h.team === 0 ? 0 : 3) + skillIdx;
            const skillData = SKILLS_DB[baseIdx];

            if(h.mp >= skillData.cost && h.skillCD[skillIdx] <= 0) {
                h.mp -= skillData.cost;
                h.skillCD[skillIdx] = skillData.cd;

                // Simple Skill implementation
                if(skillData.type === 'area' || skillData.type === 'target') {
                    // AoE around self or simple blast
                    GAME.fx.push({x:h.x, y:h.y, t:30, r:skillData.range, color:'rgba(255,255,0,0.5)'});
                    GAME.ents.filter(e => e.team !== h.team && dist(h,e) < skillData.range).forEach(e => {
                        e.hp -= skillData.dmg;
                        if(e.hp<=0) e.dead=true;
                    });
                }
            }
        }
    },
    
    endGame: (winner) => {
        GAME.running = false;
        Network.conn.send({ t:'STATE', s: {win:winner} }); // Special Packet
        UI.showEnd(winner);
    },

    // –°–æ–∑–¥–∞–µ—Ç —á–∏—Å—Ç—ã–π —Å–Ω–∞–ø—à–æ—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
    packState: () => {
        return {
            t: Server.t,
            ents: GAME.ents.map(e => ({
                id:e.id, type:e.type, team:e.team, x:Math.round(e.x), y:Math.round(e.y), 
                hp:e.hp, maxHp:e.maxHp, mp:e.mp, maxMp:e.maxMp, 
                lvl:e.lvl, gold:e.gold, cd:e.skillCD, dead:e.dead,
                // Client-side render needs basic static info too? Optimization needed for big games
            })),
            fx: GAME.fx,
            projs: GAME.projectiles.map(p => ({x:Math.round(p.x), y:Math.round(p.y), c:p.color}))
        };
    }
};

// ================= CLIENT SIDE =================
const Client = {
    myHero: null,
    
    sync: (s) => {
        if(s.win) { GAME.running = false; UI.showEnd(s.win); return; }

        // Merge state. For simplicity in this demo, we replace logic ents with render proxies
        // But client host just draws local ents.
        if(GAME.role === 'client') {
             GAME.ents = s.ents; // In real Dota, interpolations happens here
             GAME.fx = s.fx;
             GAME.projectiles = s.projs;
        }

        // HUD Update
        const myH = GAME.ents.find(e => e.type==='hero' && e.team === GAME.playerId);
        if(myH) {
            Client.myHero = myH;
            $('hud-hp').innerText = Math.round(myH.hp) + "/" + myH.maxHp;
            $('hud-gold').innerText = myH.gold;
            $('hud-lvl').innerText = myH.lvl;
            
            // Skill CDs
            [0,1,2].forEach(i => {
                let cd = myH.cd ? myH.cd[i] : 0;
                const el = document.getElementById(['cd-q','cd-w','cd-r'][i]);
                el.innerText = cd > 0 ? cd : '';
                el.style.opacity = cd > 0 ? 1 : 0;
            });
            
            // Camera follow
            GAME.camera.x = myH.x - GAME.width/2;
            GAME.camera.y = myH.y - GAME.height/2;
        }
    }
};

const Inp = {
    vx:0, vy:0,
    setup: () => {
        // Keyboard (PC)
        window.addEventListener('keydown', e => {
            if(e.code === 'KeyQ') Inp.useSkill(0);
            if(e.code === 'KeyW') Inp.useSkill(1);
            if(e.code === 'KeyR') Inp.useSkill(2);
        });

        // Mouse right click move
        $('game-view').addEventListener('contextmenu', e => {
            e.preventDefault();
            // Convert screen to world
            const rect = $('cvs').getBoundingClientRect();
            const wx = e.clientX - rect.left + GAME.camera.x;
            const wy = e.clientY - rect.top + GAME.camera.y;
            
            if(Client.myHero) {
                // Vector to target
                const dx = wx - Client.myHero.x, dy = wy - Client.myHero.y;
                const dist = Math.hypot(dx,dy);
                const nx = dx/dist, ny = dy/dist;
                Network.conn.send({ t:'INPUT', i: {type:'move', x:nx, y:ny} });
                
                // Show Move Marker
                GAME.fx.push({x:wx, y:wy, t:20, type:'mark'});
                
                // Stop automatically after reaching? (Hard in simple packet sys)
                // Just toggle off after 1 sec in this demo style
                setTimeout(() => Network.conn.send({t:'INPUT', i:{type:'move',x:0,y:0}}), dist*5);
            }
        });

        // Touch Joystick
        const j = $('joystick-zone');
        let jData = { active:false, sx:0, sy:0 };
        
        j.addEventListener('touchstart', e=>{ 
            jData.active=true; 
            const t = e.touches[0]; jData.sx = t.clientX; jData.sy = t.clientY;
        });
        j.addEventListener('touchmove', e=>{
            if(!jData.active) return;
            const t = e.touches[0];
            const dx = t.clientX - jData.sx, dy = t.clientY - jData.sy;
            const dist = Math.min(Math.hypot(dx,dy), 40);
            const ang = Math.atan2(dy, dx);
            
            const nx = Math.cos(ang), ny = Math.sin(ang);
            $('.joy-stick').style.transform = `translate(${nx*dist}px, ${ny*dist}px)`;
            
            Network.conn.send({ t:'INPUT', i: {type:'move', x:nx, y:ny} });
        });
        j.addEventListener('touchend', e=>{
             jData.active=false;
             $('.joy-stick').style.transform = `translate(0px, 0px)`;
             Network.conn.send({ t:'INPUT', i: {type:'move', x:0, y:0} });
        });
    },
    useSkill: (slot) => {
        Network.conn.send({ t:'INPUT', i: {type:'skill', slot: slot} });
    },
    attack: () => {
         // Stop command essentially
         Network.conn.send({ t:'INPUT', i: {type:'move', x:0, y:0} });
    }
};

const Render = {
    ctx: $('cvs').getContext('2d'),
    
    loop: () => {
        if(!GAME.running) return;
        requestAnimationFrame(Render.loop);
        
        // Host Logical Tick
        if(GAME.role === 'host') {
             Server.update();
             if(Server.t % 3 === 0) { // Sync rate limiter 20hz
                 Network.conn.send({ t:'STATE', s:Server.packState() });
                 Client.sync(Server.packState()); // Update local display immediately
             }
        }

        const c = Render.ctx;
        c.fillStyle = '#1e1e1e';
        c.fillRect(0,0,GAME.width, GAME.height);

        c.save();
        // Camera Translate
        c.translate(-GAME.camera.x, -GAME.camera.y);

        // Draw Map (Diagonal Lane)
        c.strokeStyle = '#333';
        c.lineWidth = 100;
        c.beginPath(); 
        c.moveTo(100, 2000-100); c.lineTo(2000-100, 100); 
        c.stroke(); // River/Path visual
        
        c.strokeStyle = 'cyan'; c.lineWidth = 20; // River center
        c.beginPath(); c.moveTo(0, 2000); c.lineTo(2000, 0); c.stroke();

        // Draw Ents
        GAME.ents.forEach(e => {
            if(e.dead) return;

            // Visuals
            const size = e.type==='hero'?20 : e.type==='tower'?30:e.type==='ancient'?50:10;
            c.fillStyle = e.team === 0 ? (e.type==='creep'?'#363':'#4f4') : (e.type==='creep'?'#633':'#f44');
            
            // Shadows
            c.beginPath(); c.ellipse(e.x, e.y+size, size, size/2, 0, 0, Math.PI*2);
            c.fillStyle="rgba(0,0,0,0.5)"; c.fill();

            // Body
            c.fillStyle = e.type === 'hero' ? (e.team===0 ? HEROES.knight.color : HEROES.mage.color) : (e.team===0?'#686':'#866');
            if(e.type === 'tower') c.fillStyle = '#aaa';
            
            c.beginPath(); c.arc(e.x, e.y, size, 0, Math.PI*2); c.fill();
            c.lineWidth=2; c.strokeStyle="#000"; c.stroke();

            // HP Bar
            const barW = size*2;
            const pct = e.hp / e.maxHp;
            c.fillStyle = '#000'; c.fillRect(e.x-barW/2, e.y-size-15, barW, 6);
            c.fillStyle = e.team===GAME.playerId ? '#0f0' : '#f00'; 
            c.fillRect(e.x-barW/2, e.y-size-15, barW*pct, 6);
            
            // Name/Level
            if(e.type === 'hero') {
                c.fillStyle = '#fff'; c.font = "10px sans-serif"; c.textAlign="center";
                c.fillText(`Lv.${e.lvl}`, e.x, e.y - size - 18);
            }
        });

        // Projectiles
        GAME.projectiles.forEach(p => {
             c.fillStyle = p.color || '#fff';
             c.beginPath(); c.arc(p.x, p.y, 4, 0, Math.PI*2); c.fill();
        });

        // FX
        GAME.fx.forEach(f => {
            if(f.txt) { c.fillStyle = '#fff'; c.font="14px bold monospace"; c.fillText(f.txt, f.x, f.y - (30-f.t)); }
            if(f.r) { c.fillStyle=f.color; c.beginPath(); c.arc(f.x,f.y, f.r * (f.t/30), 0, Math.PI*2); c.fill(); }
            if(f.type === 'mark') { c.strokeStyle = '#0f0'; c.beginPath(); c.moveTo(f.x-5, f.y); c.lineTo(f.x+5, f.y); c.moveTo(f.x, f.y-5); c.lineTo(f.x, f.y+5); c.stroke();}
        });

        c.restore();
    }
};

const GameLogic = {
    start: () => {
        UI.show('scr-game');
        
        // Resize Canvas
        const updateSz = () => { GAME.width=$('game-view').clientWidth; GAME.height=$('game-view').clientHeight; $('cvs').width=GAME.width; $('cvs').height=GAME.height; };
        window.onresize = updateSz; updateSz();

        Inp.setup();
        
        // Load Icons (Mockup)
        const role = GAME.role==='host' ? HEROES.knight : HEROES.mage;
        $('icon-q').innerText = role.skills[0];
        $('icon-w').innerText = role.skills[1];
        $('icon-r').innerText = role.skills[2];

        // –¢–æ–ª—å–∫–æ —Ö–æ—Å—Ç –∏–Ω–∏—Ç–∏—Ç –º–∏—Ä
        if(GAME.role === 'host') {
            GAME.ents = [];
            // Spawn Ancients
            Server.spawn('ancient', 0, 100, 2000-100);
            Server.spawn('ancient', 1, 2000-100, 100);
            
            // Towers
            Server.spawn('tower', 0, 400, 2000-400);
            Server.spawn('tower', 1, 2000-400, 400);
            
            // Heroes
            Server.spawn('hero', 0, 150, 2000-150); // Radiant Player
            Server.spawn('hero', 1, 2000-150, 150); // Dire Player

            Network.conn.send({ t:'START' }); // Start signal to client
        }

        GAME.running = true;
        Render.loop();
    }
};

const UI = {
    show: (id) => {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        $(id).classList.remove('hidden');
        if(id==='scr-game') $(id).style.display = 'flex';
    },
    toJoin: () => UI.show('scr-join'),
    showEnd: (winTeam) => {
        $('end-screen').style.display = 'flex';
        $('end-title').innerText = winTeam + " VICTORY";
        $('end-title').style.color = winTeam === 'Radiant' ? '#4CAF50' : '#F44336';
    }
};

</script>
</body>
</html>
