<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <!-- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–±—Ä–∞–Ω—ã user-scalable=no –∏ maximum-scale –¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>POCKET DOTA: REMASTERED</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --rad: #4CAF50; --dire: #F44336; --gold: #FFD700; --mana: #00B0FF; }
        
        * { 
            box-sizing: border-box; 
            outline: none; 
            
            /* –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –±—Ä–∞—É–∑–µ—Ä–∞ —á–µ—Ä–µ–∑ CSS */
            touch-action: none; 
            -webkit-tap-highlight-color: transparent;
            
            /* –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ Safari –¥–ª—è –∑–∞–ø—Ä–µ—Ç–∞ –≤—ã–¥–µ–ª–µ–Ω–∏—è */
            user-select: none;
            -webkit-user-select: none;
        }
        
        body { 
            margin: 0; overflow: hidden; background: #000; font-family: 'Roboto', sans-serif; 
            color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
        }

        /* UI SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(#1e2228, #000);
            z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; display: none !important; }

        h1 { font-family: 'Cinzel', serif; font-size: 3rem; color: #ccc; text-shadow: 0 0 10px #aa0000; margin-bottom: 0.5rem; letter-spacing: 5px; text-align: center;}
        
        .box {
            background: rgba(20,20,30, 0.85); padding: 30px; border: 1px solid #444; 
            box-shadow: 0 0 20px rgba(0,0,0,0.8); border-radius: 8px; max-width: 500px; width: 90%; text-align: center;
            
            /* –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ Safari –¥–ª—è –±–ª—é—Ä–∞ */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        button {
            background: linear-gradient(180deg, #3a4b5d, #252e38); color: #fff; border: 1px solid #666;
            padding: 15px 30px; margin: 10px 0; font-size: 1.1rem; font-family: 'Cinzel', serif; cursor: pointer; width: 100%;
            transition: 0.2s; border-radius: 4px;
        }
        button:hover { filter: brightness(1.2); border-color: #888; }
        button:active { transform: translateY(2px); }
        
        /* –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: Input field –≤–∏–∑—É–∞–ª—å–Ω–æ –ø—Ä–∏—è—Ç–Ω–µ–µ –∏ –±–æ–ª—å—à–µ */
        input { 
            width: 100%; padding: 15px; background: #111; border: 1px solid #444; 
            color: #fff; margin-bottom: 10px; font-family: monospace; font-size: 1.2rem; text-align: center; 
            border-radius: 4px;
            /* –†–∞–∑—Ä–µ—à–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —Ç–æ–ª—å–∫–æ –≤ input */
            user-select: text; -webkit-user-select: text;
        }

        /* GAME HUD */
        #game-view { position: relative; width: 100%; height: 100%; overflow: hidden; cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; background: #0b0f0a; }

        .top-bar {
            position: absolute; top: 0; width: 100%; height: 50px; background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: center; padding: 0 20px; font-family: 'Cinzel'; pointer-events: none;
        }
        .hero-portrait { width: 50px; height: 50px; border: 2px solid #555; background: #222; margin-top: 10px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; }
        
        /* Skill Controls */
        .controls-layer { pointer-events: none; position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: flex-end; padding-bottom: 20px;}
        
        .skill-dock {
            pointer-events: auto; display: flex; gap: 15px; margin: 0 auto; background: rgba(0,0,0,0.6); 
            padding: 10px; border-radius: 12px; border: 1px solid #333;
            /* Safari support */
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .skill-btn {
            width: 65px; height: 65px; background: #222; border: 2px solid #555; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px;
            touch-action: none; /* Critical for quick tapping */
        }
        .skill-btn:active { border-color: #fff; transform: scale(0.95); }
        .skill-key { position: absolute; top: 2px; left: 4px; font-size: 0.6rem; color: #888; font-weight: bold; }
        .skill-icon { font-size: 1.8rem; }
        .cd-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: flex; align-items: center; justify-content: center; font-weight: bold; color: #fff; border-radius: 6px; }
        
        /* Joystick for mobile */
        #joystick-zone { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; pointer-events: auto; z-index: 20; }
        .joy-base { width: 100%; height: 100%; background: rgba(255,255,255,0.05); border: 2px dashed rgba(255,255,255,0.2); border-radius: 50%; position:relative; }
        .joy-stick { position:absolute; top:30%; left:30%; width: 40%; height: 40%; background: rgba(255,255,255,0.2); border-radius: 50%; box-shadow: 0 0 10px #000; pointer-events: none; }

        @media (min-width: 800px) {
            #joystick-zone { display: none; }
            .skill-dock { margin-bottom: 20px; }
        }
    </style>
</head>
<!-- –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∏–≥—Ä—ã -->
<body oncontextmenu="return false;">

<!-- MENU -->
<div id="scr-menu" class="screen">
    <h1>DOTA P2P</h1>
    <div class="box">
        <button onclick="Network.host()" style="border-bottom: 4px solid var(--rad);">HOST GAME (Radiant)</button>
        <div style="margin: 10px 0; color: #666; font-size: 0.8rem;">Requires Internet Connection</div>
        <button onclick="UI.toJoin()" style="border-bottom: 4px solid var(--dire);">JOIN GAME (Dire)</button>
    </div>
</div>

<!-- JOIN -->
<div id="scr-join" class="screen hidden">
    <div class="box">
        <h3>Connect to Server</h3>
        <!-- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω label –¥–ª—è –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ -->
        <label for="host-id-input" style="font-size:0.8rem; display:block; margin-bottom:5px; color:#aaa;">Enter Host ID:</label>
        <input type="text" id="host-id-input" placeholder="paste-id-here">
        <button onclick="Network.join()">Connect</button>
        <button onclick="location.reload()" style="background:transparent; border:none; margin-top:0;">Back</button>
    </div>
</div>

<!-- LOBBY -->
<div id="scr-lobby" class="screen hidden">
    <div class="box">
        <h3>Your Lobby</h3>
        <p style="color:#aaa; font-size:0.9rem;">Send this ID to your friend:</p>
        
        <!-- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ù–æ–≤—ã–π –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –∏–Ω–ø—É—Ç —Å –∫–Ω–æ–ø–∫–æ–π –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è -->
        <div style="position: relative;">
            <label for="my-id-display" class="hidden">My ID</label>
            <input type="text" id="my-id-display" readonly style="color: var(--gold); border-color: var(--gold); cursor: pointer;" aria-label="Game Lobby ID">
            <button onclick="UI.copyId()" style="font-size: 0.8rem; padding: 5px;">COPY ID üìã</button>
        </div>

        <div id="status-msg" style="color: var(--rad); margin-top: 15px; font-weight:bold;">Waiting for player...</div>
    </div>
</div>

<!-- GAME -->
<div id="scr-game" class="screen hidden" style="background: transparent;">
    <div id="game-view">
        <canvas id="cvs"></canvas>
        <div class="top-bar">
            <div class="hero-portrait" style="border-color:var(--rad)">üõ°Ô∏è</div>
            <div style="font-size:1.5rem;">
                <span style="color:var(--rad)" id="s-rad">0</span> 
                <span style="font-size:1rem; margin:0 10px;" id="g-time">00:00</span> 
                <span style="color:var(--dire)" id="s-dire">0</span>
            </div>
            <div class="hero-portrait" style="border-color:var(--dire)">üî•</div>
        </div>

        <div class="controls-layer">
            <div class="skill-dock">
                <div class="skill-btn" onpointerdown="Inp.sk(0)" id="b-q"><div class="skill-key">Q</div><div id="i-q" class="skill-icon">‚ö°</div><div id="cd-0" class="hidden cd-overlay"></div></div>
                <div class="skill-btn" onpointerdown="Inp.sk(1)" id="b-w"><div class="skill-key">W</div><div id="i-w" class="skill-icon">üå™Ô∏è</div><div id="cd-1" class="hidden cd-overlay"></div></div>
                <div class="skill-btn" onpointerdown="Inp.sk(2)" style="border-color: gold;" id="b-r"><div class="skill-key">R</div><div id="i-r" class="skill-icon">‚òÑÔ∏è</div><div id="cd-2" class="hidden cd-overlay"></div></div>
            </div>
            <!-- Joystick Container -->
            <div id="joystick-zone">
                <div class="joy-base" id="joy-control"><div class="joy-stick"></div></div>
            </div>
        </div>
    </div>
    
    <!-- End Screen -->
    <div id="end-overlay" class="screen hidden" style="background: rgba(0,0,0,0.85); z-index: 100;">
        <h1 id="win-msg" style="font-size:4rem;">VICTORY</h1>
        <button onclick="location.reload()" style="max-width:200px">MAIN MENU</button>
    </div>
</div>

<script>
// === UTIL & CONFIG ===
const $ = (id) => document.getElementById(id);
const HEROES = [
    { name:"Radiant", c:"#4CAF50", hp:600, skills:["üî®","üõ°Ô∏è","üëë"], stats:[45,4,2] }, // dmg, spd, regen
    { name:"Dire", c:"#F44336", hp:500, skills:["üî•","üëø","üå©Ô∏è"], stats:[55,3.8,1] }
];

// === SYSTEM: INPUT & COMPATIBILITY ===
const UI = {
    show: (id) => {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        $(id).classList.remove('hidden');
    },
    toJoin: () => UI.show('scr-join'),
    
    // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Clipboard API –≤–º–µ—Å—Ç–æ —É—Å—Ç–∞—Ä–µ–≤—à–µ–≥–æ execCommand
    copyId: async () => {
        const inp = $('my-id-display');
        try {
            await navigator.clipboard.writeText(inp.value);
            inp.style.background = '#252'; 
            setTimeout(()=>inp.style.background='#111', 500);
        } catch (err) {
            // Fallback for older browsers
            inp.select();
            document.execCommand('copy');
        }
    },
    
    updateCD: (hero) => {
        [0,1,2].forEach(i => {
            const el = $(`cd-${i}`);
            const cd = hero.cd[i];
            if(cd > 0) {
                el.classList.remove('hidden'); el.innerText = Math.ceil(cd/60);
            } else {
                el.classList.add('hidden');
            }
        });
    },
    end: (win) => {
        $('win-msg').innerText = win ? "VICTORY" : "DEFEAT";
        $('win-msg').style.color = win ? "gold" : "gray";
        $('end-overlay').classList.remove('hidden');
    }
};

// === GAME LOGIC CORE ===
const Game = {
    running: false, role: '', pid: 0,
    w: 1200, h: 1200, cam: {x:0, y:0},
    ents: [], fx: [],
    
    init: (role, pid) => {
        Game.role = role; Game.pid = pid;
        $('i-q').innerText = HEROES[pid].skills[0];
        $('i-w').innerText = HEROES[pid].skills[1];
        $('i-r').innerText = HEROES[pid].skills[2];
        
        // Setup Resize
        const rsz = () => { $('cvs').width = window.innerWidth; $('cvs').height = window.innerHeight; };
        window.onresize = rsz; rsz();
        
        UI.show('scr-game');
        if(role === 'host') Host.start();
        Inp.bind();
        Render.loop();
    }
};

// === NETWORK ===
const Net = {
    peer: null, conn: null,
    host: () => {
        Game.pid = 0; UI.show('scr-lobby');
        Net.init();
    },
    join: () => {
        const id = $('host-id-input').value.trim();
        if(!id) return alert("Enter ID");
        Game.pid = 1; UI.show('scr-lobby');
        Net.init(id);
    },
    init: (targetId) => {
        Net.peer = new Peer({ debug: 1 });
        Net.peer.on('open', id => {
            if(!targetId) $('my-id-display').value = id;
            else Net.conn = Net.peer.connect(targetId);
        });
        
        Net.peer.on('connection', c => { // I am host
            Net.conn = c; Host.setup();
        });
        
        // Client Handling
        if(targetId) setTimeout(() => {
            if(Net.conn) {
                Net.conn.on('open', () => $('status-msg').innerText = "Connected! Waiting Host...");
                Net.conn.on('data', d => {
                    if(d.t === 'STATE') Client.sync(d.s);
                });
            }
        }, 1000);
    }
};

// === LOGIC (HOST) ===
const Host = {
    t: 0, 
    setup: () => {
        $('status-msg').innerText = "Player Found! Starting...";
        Net.conn.on('data', d => { if(d.t==='INP') Host.inpBuffer = d.val; });
        setTimeout(() => {
            Game.ents = [
                Host.crHero(0, 100, Game.h-100), // Rad Hero
                Host.crHero(1, Game.w-100, 100), // Dire Hero
                {id:'t1', t:'tower', team:0, x:300, y:Game.h-300, hp:800, max:800},
                {id:'t2', t:'tower', team:1, x:Game.w-300, y:300, hp:800, max:800},
                {id:'a1', t:'throne', team:0, x:50, y:Game.h-50, hp:1500, max:1500},
                {id:'a2', t:'throne', team:1, x:Game.w-50, y:50, hp:1500, max:1500}
            ];
            Net.conn.send({t:'STATE', s: Host.pack()}); // First sync
            Game.init('host', 0);
        }, 1000);
    },
    crHero: (team, x, y) => ({
        id:`h${team}`, t:'hero', team, x, y, hp:HEROES[team].hp, max:HEROES[team].hp,
        cd:[0,0,0], dead:0, vx:0, vy:0, stat:HEROES[team].stats
    }),
    start: () => {
        Game.running = true;
        Host.loop();
    },
    loop: () => {
        if(!Game.running) return;
        requestAnimationFrame(Host.loop);
        Host.t++;
        
        // Spawn Creeps
        if(Host.t % 900 === 0) { // 15 sec
            Game.ents.push({id:`c${Math.random()}`, t:'creep', team:0, x:150, y:Game.h-150, hp:100, max:100});
            Game.ents.push({id:`c${Math.random()}`, t:'creep', team:1, x:Game.w-150, y:150, hp:100, max:100});
        }
        
        // Physics
        Game.ents.forEach(e => {
            if(e.dead) return;
            
            // Movement (Hero)
            if(e.t === 'hero') {
                let inp = e.team === 0 ? Inp.curr : Host.inpBuffer;
                if(inp) {
                    e.x += inp.x * e.stat[1]; 
                    e.y += inp.y * e.stat[1];
                    e.x = Math.max(0, Math.min(Game.w, e.x));
                    e.y = Math.max(0, Math.min(Game.h, e.y));
                    
                    // Attack
                    if(inp.a && Host.t % 30 === 0) Host.atk(e);
                    // Skills
                    if(inp.s !== -1) Host.useSkill(e, inp.s);
                }
            }
            // Creep AI (Simplified Diagonal)
            if(e.t === 'creep') {
                let tx = e.team===0?Game.w:0, ty = e.team===0?0:Game.h;
                // Find Target
                let en = Game.ents.find(x=> !x.dead && x.team!==e.team && Math.hypot(x.x-e.x,x.y-e.y)<300);
                if(en) { tx=en.x; ty=en.y; if(Math.hypot(tx-e.x, ty-e.y)<30) {tx=e.x; ty=e.y; if(Host.t%60===0) Host.dmg(e,en,10);} }
                let ang = Math.atan2(ty-e.y, tx-e.x);
                if(Math.hypot(tx-e.x, ty-e.y)>5) { e.x+=Math.cos(ang)*2; e.y+=Math.sin(ang)*2; }
            }
            // Cooldowns
            if(e.cd) e.cd = e.cd.map(x => Math.max(0, x-1));
        });
        
        Host.inpBuffer = {x:0, y:0, s:-1}; // Clear buffer
        
        if(Host.t % 2 === 0 && Net.conn) Net.conn.send({t:'STATE', s:Host.pack()});
    },
    atk: (u) => {
        let t = Game.ents.find(e=> !e.dead && e.team!==u.team && Math.hypot(e.x-u.x, e.y-u.y)<100);
        if(t) Host.dmg(u, t, u.stat[0]);
    },
    dmg: (src, trg, am) => {
        trg.hp -= am;
        Game.fx.push({x:trg.x, y:trg.y, txt:`-${am}`, t:20});
        if(trg.hp <= 0) {
            trg.dead = 1;
            if(trg.t === 'throne') Net.conn.send({t:'STATE', s:{win:src.team}});
        }
    },
    useSkill: (u, idx) => {
        if(u.cd[idx] > 0) return;
        u.cd[idx] = [120, 300, 600][idx]; // CD
        // Simple logic: Skill = Big AOE Damage
        Game.ents.forEach(e => {
            if(e.team !== u.team && Math.hypot(e.x-u.x, e.y-u.y) < [150, 200, 400][idx])
                Host.dmg(u, e, [80, 0, 250][idx]); 
        });
        Game.fx.push({x:u.x, y:u.y, r:[50,80,200][idx], c:HEROES[u.team].c, t:20});
    },
    pack: () => ({ ents: Game.ents.map(e => ({...e})), fx: Game.fx, t: Host.t }),
    inpBuffer: null
};

// === LOGIC (CLIENT) ===
const Client = {
    sync: (s) => {
        if(s.win !== undefined) return UI.end(s.win === Game.pid);
        Game.ents = s.ents;
        Game.fx = s.fx;
        if(Game.pid === 1) Net.conn.send({t:'INP', val: Inp.curr});
        
        const my = Game.ents.find(e => e.t === 'hero' && e.team === Game.pid);
        if(my) UI.updateCD(my);
    }
};

// === INPUT (TOUCH & MOUSE) ===
const Inp = {
    curr: {x:0, y:0, a:false, s:-1},
    bind: () => {
        // Desktop keys
        window.onkeydown = (e) => {
            if(e.key==='q') Inp.sk(0); 
            if(e.key==='w') Inp.sk(1);
            if(e.key==='r') Inp.sk(2);
            if(e.code==='Space') Inp.curr.a = true;
        };
        window.onkeyup = (e) => { if(e.code==='Space') Inp.curr.a = false; };
        
        // Desktop Mouse Move (Right Click)
        $('cvs').oncontextmenu = (e) => {
            e.preventDefault();
            const rect = $('cvs').getBoundingClientRect();
            // Simple nav logic sim
            const tx = e.clientX - rect.left + Game.cam.x;
            const ty = e.clientY - rect.top + Game.cam.y;
            // Normally would need vector math, keeping joystick primary for size
        };
        
        // JOYSTICK
        const joy = $('joy-control');
        let active = false;
        const start = {x:0, y:0};
        const stick = joy.querySelector('.joy-stick');
        
        const move = (cx, cy) => {
            let dx = cx - start.x, dy = cy - start.y;
            let h = Math.hypot(dx,dy);
            let dist = Math.min(h, 50);
            let ang = Math.atan2(dy, dx);
            let nx = Math.cos(ang), ny = Math.sin(ang);
            stick.style.transform = `translate(${nx*dist}px, ${ny*dist}px)`;
            Inp.curr.x = nx; Inp.curr.y = ny;
        };
        
        joy.ontouchstart = (e) => {
            active=true; 
            const r = joy.getBoundingClientRect();
            start.x = r.left + r.width/2; 
            start.y = r.top + r.height/2;
            move(e.touches[0].clientX, e.touches[0].clientY);
            Inp.curr.a = true; // Auto attack when moving
        };
        joy.ontouchmove = (e) => { if(active) move(e.touches[0].clientX, e.touches[0].clientY); };
        joy.ontouchend = () => { active=false; stick.style.transform=''; Inp.curr.x=0; Inp.curr.y=0; Inp.curr.a=false; };
    },
    sk: (i) => {
        Inp.curr.s = i;
        setTimeout(()=>Inp.curr.s=-1, 100); // Trigger once
    }
};

// === RENDERER ===
const Render = {
    loop: () => {
        requestAnimationFrame(Render.loop);
        const ctx = $('cvs').getContext('2d');
        const cw = $('cvs').width, ch = $('cvs').height;
        
        // Cam follow
        const me = Game.ents.find(e => e.team === Game.pid && e.t === 'hero');
        if(me) {
            Game.cam.x = me.x - cw/2; 
            Game.cam.y = me.y - ch/2;
        }
        
        ctx.fillStyle = '#0b0f0a'; ctx.fillRect(0,0,cw,ch);
        ctx.save();
        ctx.translate(-Game.cam.x, -Game.cam.y);
        
        // Grid
        ctx.strokeStyle = '#222'; ctx.lineWidth=2;
        ctx.beginPath();
        for(let i=0; i<Game.w; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i, Game.h); }
        for(let i=0; i<Game.h; i+=100) { ctx.moveTo(0,i); ctx.lineTo(Game.w, i); }
        ctx.stroke();
        
        // Diagonal River
        ctx.strokeStyle = '#0055aa'; ctx.lineWidth=40;
        ctx.beginPath(); ctx.moveTo(0,Game.h); ctx.lineTo(Game.w,0); ctx.stroke();
        
        // Ents
        Game.ents.forEach(e => {
            if(e.dead) return;
            const sz = e.t==='hero'?20 : e.t==='tower'?40 : e.t==='throne'?60 : 10;
            const c = e.team===0 ? '#4f4' : '#f44';
            
            // Draw
            ctx.shadowColor = c; ctx.shadowBlur = 10; ctx.fillStyle = c;
            if(e.t === 'throne') {
                ctx.fillRect(e.x-sz/2, e.y-sz/2, sz, sz);
            } else {
                ctx.beginPath(); ctx.arc(e.x, e.y, sz, 0, Math.PI*2); ctx.fill();
            }
            ctx.shadowBlur = 0;
            
            // HP
            ctx.fillStyle = '#000'; ctx.fillRect(e.x-20, e.y-sz-10, 40, 5);
            ctx.fillStyle = e.team === Game.pid ? '#0f0' : '#f00';
            ctx.fillRect(e.x-20, e.y-sz-10, 40 * (e.hp/e.max), 5);
        });
        
        // FX
        ctx.font = "bold 15px monospace";
        Game.fx.forEach(f => {
            f.t--;
            if(f.txt) { ctx.fillStyle='white'; ctx.fillText(f.txt, f.x, f.y-20+(f.t)); }
            if(f.r) { 
                ctx.fillStyle=f.c; ctx.globalAlpha=f.t/20; 
                ctx.beginPath(); ctx.arc(f.x,f.y, f.r, 0, 6); ctx.fill(); ctx.globalAlpha=1; 
            }
        });
        Game.fx = Game.fx.filter(f => f.t > 0);
        
        ctx.restore();
    }
};
</script>
</body>
</html>
