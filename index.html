<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ULTIMATE GAME PACK</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&family=Roboto:wght@300&display=swap" rel="stylesheet">
    <style>
        :root { --p1: #00ffff; --p2: #ff0055; --bg: #050510; --ui-bg: rgba(0,0,0,0.85); }
        * { box-sizing: border-box; touch-action: none; user-select: none; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body { 
            margin: 0; padding: 0; overflow: hidden; background: var(--bg); 
            font-family: 'Orbitron', sans-serif; color: white;
        }

        /* --- UI Screens --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
            z-index: 100; transition: opacity 0.5s;
        }
        .hidden { opacity: 0; pointer-events: none; z-index: -1; display: none !important; }

        h1 { font-size: 2.5rem; text-shadow: 0 0 20px var(--p1); text-transform: uppercase; margin: 0 0 30px 0; text-align: center;}
        h2 { color: #aaa; font-family: 'Roboto'; font-size: 1rem; margin-bottom: 20px; }
        
        .panel { 
            background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px; 
            border: 1px solid rgba(255,255,255,0.1); display: flex; flex-direction: column; align-items: center; gap: 10px;
            backdrop-filter: blur(10px); width: 90%; max-width: 400px;
        }

        button {
            width: 100%; padding: 18px; font-size: 1.1rem; border: none; border-radius: 8px;
            background: linear-gradient(90deg, #222, #333); color: white; font-family: 'Orbitron'; cursor: pointer;
            box-shadow: 0 4px 0 #000; transition: transform 0.1s; text-transform: uppercase;
        }
        button:active { transform: translateY(4px); box-shadow: none; }
        button.primary { background: linear-gradient(45deg, var(--p1), #0088ff); color: #000; font-weight: 900; }
        button.secondary { background: #333; border: 1px solid #555; }
        
        input { 
            width: 100%; padding: 15px; font-size: 1.2rem; background: #000; border: 1px solid #444; color: var(--p1);
            text-align: center; border-radius: 8px; font-family: monospace; letter-spacing: 2px;
        }

        /* --- DEBUG CONSOLE (–û–ß–ï–ù–¨ –í–ê–ñ–ù–û) --- */
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; padding: 5px;
            font-family: monospace; font-size: 0.7rem; color: #ffff00;
            background: rgba(0,0,0,0.5); pointer-events: none; z-index: 1000; white-space: pre-wrap;
        }

        /* --- GAME UI --- */
        #game-layer { position: relative; width: 100%; height: 100%; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }

        .hud-top {
            position: absolute; top: 10px; width: 100%; padding: 0 20px;
            display: flex; justify-content: space-between; font-size: 1.5rem; font-weight: bold;
            text-shadow: 2px 2px 0 #000; pointer-events: none;
        }

        /* Controls */
        #controls-stick { position: absolute; bottom: 20px; left: 20px; pointer-events: auto; }
        #controls-action { position: absolute; bottom: 20px; right: 20px; pointer-events: auto; }
        
        .joystick-base {
            width: 120px; height: 120px; border-radius: 50%; 
            background: rgba(255, 255, 255, 0.05); border: 2px dashed rgba(255,255,255,0.2);
            position: relative; display: flex; align-items: center; justify-content: center;
        }
        .joystick-stick {
            width: 50px; height: 50px; border-radius: 50%; background: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 15px var(--p1); transform: translate(0,0); position: absolute;
        }
        
        /* Clash Cards */
        #card-dock {
            position: absolute; bottom: 10px; width: 100%; display: flex; justify-content: center; gap: 10px;
            pointer-events: auto;
        }
        .card {
            width: 60px; height: 80px; background: #222; border: 2px solid #555; border-radius: 6px;
            display: flex; flex-direction: column; align-items: center; justify-content: space-around;
            font-size: 0.7rem; position: relative; cursor: pointer; transition: 0.2s;
        }
        .card.active { border-color: #0f0; box-shadow: 0 0 10px #0f0; background: #002200; transform: translateY(-5px); }
        .cost-bubble { position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background: #a0f; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; }

    </style>
</head>
<body>

<!-- SYSTEM LOGS -->
<div id="debug-console">Build: v3.0 Ultimate | Status: Init...</div>

<!-- SCREEN 1: MENU -->
<div id="scr-menu" class="screen">
    <h1>GamePack v3.0</h1>
    <div class="panel">
        <button class="primary" onclick="Net.host()">üëë –°–æ–∑–¥–∞—Ç—å –°–µ—Ä–≤–µ—Ä</button>
        <div style="width:100%; height:1px; background:#444; margin:10px 0;"></div>
        <button class="secondary" onclick="UI.show('scr-lobby')">ü§ù –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
        <p style="font-size:0.8rem; color:#666">–†–∞–±–æ—Ç–∞–µ—Ç —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç (P2P)</p>
    </div>
</div>

<!-- SCREEN 2: LOBBY -->
<div id="scr-lobby" class="screen hidden">
    <h2>–í–í–û–î ID –°–ï–†–í–ï–†–ê</h2>
    <div class="panel">
        <input type="text" id="join-inp" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ ID —Å—é–¥–∞...">
        <button class="primary" onclick="Net.join()">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
        <button class="secondary" onclick="UI.show('scr-menu')">–ù–∞–∑–∞–¥</button>
    </div>
</div>

<!-- SCREEN 3: HOST ROOM -->
<div id="scr-room" class="screen hidden">
    <h2>–ö–æ–º–Ω–∞—Ç–∞ –û–∂–∏–¥–∞–Ω–∏—è</h2>
    <div class="panel">
        <div id="my-id-display" style="color:var(--p1); font-size:1.5rem; word-break: break-all; text-align:center;">...</div>
        <div style="font-size:0.8rem; color:#aaa">–°–∫–æ–ø–∏—Ä—É–π —ç—Ç–æ—Ç –∫–æ–¥ –∏ —Å–∫–∏–Ω—å –¥—Ä—É–≥—É</div>
        <div id="player-status" style="margin-top:20px; font-weight:bold; color:orange">–û–∂–∏–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ 2...</div>
        <hr style="width:100%; border-color:#333">
        <div id="game-selector" class="hidden" style="width:100%">
            <p>–í—ã–±–µ—Ä–∏—Ç–µ –∏–≥—Ä—É:</p>
            <button class="primary" onclick="Game.start('tanks')" style="margin-bottom:10px">üöú NEON TANKS</button>
            <button class="primary" onclick="Game.start('clash')" style="background: linear-gradient(45deg, #aa00ff, #ff00aa)">‚öîÔ∏è CYBER CLASH</button>
            <button class="primary" onclick="Game.start('dots')" style="margin-top:10px; background:#444">üî¥ DOT HUNTER</button>
        </div>
    </div>
</div>

<!-- SCREEN 4: GAME -->
<div id="scr-game" class="hidden">
    <div id="game-layer">
        <canvas id="ctx"></canvas>
        <div class="hud-top">
            <span style="color:var(--p1)">P1: <span id="s1">0</span></span>
            <div id="game-timer" style="color:white; font-size:1rem; opacity:0.5">00:00</div>
            <span style="color:var(--p2)">P2: <span id="s2">0</span></span>
        </div>

        <!-- Sticks UI -->
        <div id="controls-stick">
            <div class="joystick-base" id="joy-move"><div class="joystick-stick"></div></div>
        </div>
        <div id="controls-action">
            <div class="joystick-base" id="joy-act" style="border-color:rgba(255,0,85,0.3)"><div class="joystick-stick" style="background:rgba(255,0,85,0.5)"></div></div>
        </div>
        
        <!-- Clash UI -->
        <div id="clash-ui" class="hidden">
            <div style="position:absolute; bottom:120px; left:10px; width:20px; height:150px; background:#222; border:1px solid #555">
                <div id="elixir-fill" style="width:100%; height:0%; background:#a0f; position:absolute; bottom:0; transition:0.2s"></div>
            </div>
            <div id="card-dock"></div>
        </div>
    </div>
</div>

<script>
// === GLOBAL LOG SYSTEM (–î–ª—è –æ—Ç–ª–∞–¥–∫–∏ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ) ===
function log(msg) {
    const d = document.getElementById('debug-console');
    const t = new Date().toLocaleTimeString();
    d.innerHTML = `[${t}] ${msg}\n` + d.innerHTML;
    if(d.innerHTML.length > 500) d.innerHTML = d.innerHTML.substring(0, 500);
}
window.onerror = function(msg, url, line) { log("ERR: " + msg + " at " + line); };

// === NETWORK MODULE (PEERJS WRAPPER) ===
const Net = {
    peer: null, conn: null, role: null, id: null,
    
    host: () => {
        Net.role = 'host';
        Net.initPeer();
    },
    join: () => {
        const id = document.getElementById('join-inp').value.trim();
        if(!id) return alert("–í–≤–µ–¥–∏—Ç–µ ID!");
        Net.role = 'client';
        Net.initPeer(id);
    },
    initPeer: (connectToId = null) => {
        log("Init Peer...");
        // –í–ê–ñ–ù–û: –ú—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±–ª–∞—á–Ω—ã–π —Å–µ—Ä–≤–µ—Ä PeerJS. –ò–Ω–æ–≥–¥–∞ –æ–Ω –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω.
        Net.peer = new Peer({ debug: 1 });
        
        Net.peer.on('open', (id) => {
            Net.id = id;
            log(`MY ID: ${id}`);
            if(Net.role === 'host') {
                UI.show('scr-room');
                document.getElementById('my-id-display').innerText = id;
            } else if(connectToId) {
                Net.connect(connectToId);
            }
        });

        Net.peer.on('connection', (c) => {
            log("Incoming connection...");
            Net.conn = c;
            Net.setupConn();
        });

        Net.peer.on('error', (err) => {
            log(`PEER ERROR: ${err.type}`);
            alert(`–û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ${err.type}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ Wi-Fi –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç–µ.`);
        });
        
        Net.peer.on('disconnected', () => {
             log("Peer Disconnected. Reconnecting...");
             Net.peer.reconnect();
        });
    },
    connect: (destId) => {
        log(`Connecting to ${destId}...`);
        Net.conn = Net.peer.connect(destId);
        Net.setupConn();
    },
    setupConn: () => {
        Net.conn.on('open', () => {
            log("CONNECTED TO PARTNER!");
            if(Net.role === 'host') {
                document.getElementById('player-status').innerText = "–ò–≥—Ä–æ–∫ 2 –ø–æ–¥–∫–ª—é—á–µ–Ω!";
                document.getElementById('player-status').style.color = "#0f0";
                document.getElementById('game-selector').classList.remove('hidden');
            } else {
                UI.show('scr-lobby');
                document.querySelector('#scr-lobby h2').innerText = "–û–∂–∏–¥–∞–µ–º –≤—ã–±–æ—Ä–∞ –∏–≥—Ä—ã...";
            }
        });

        Net.conn.on('data', (data) => {
            if(data.type === 'START') { Game.init(data.mode); }
            if(data.type === 'STATE') { Game.syncState(data.st); }
            if(data.type === 'INPUT') { Logic.p2Inp = data.val; }
        });
        
        Net.conn.on('close', () => { alert("–í—Ç–æ—Ä–æ–π –∏–≥—Ä–æ–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è!"); location.reload(); });
    }
};

// === GAME ENGINE ===
const CONFIG = {
    w: 0, h: 0, 
    c: { p1: '#0ff', p2: '#f05', wall: '#ddd', bullet: '#ffaa00' }
};

const Input = { 
    x:0, y:0, ax:0, ay:0, action: false, spawnIdx: null,
    reset: () => { Input.x=0; Input.y=0; Input.ax=0; Input.ay=0; Input.action=false; Input.spawnIdx=null; } 
};

const Game = {
    mode: null, running: false, 
    ctx: document.getElementById('ctx').getContext('2d'),

    start: (mode) => {
        if(Net.conn) Net.conn.send({ type: 'START', mode: mode });
        Game.init(mode);
    },
    init: (mode) => {
        log(`Starting Game: ${mode}`);
        Game.mode = mode;
        CONFIG.w = window.innerWidth; CONFIG.h = window.innerHeight;
        document.getElementById('ctx').width = CONFIG.w;
        document.getElementById('ctx').height = CONFIG.h;
        
        UI.show('scr-game');
        
        // Setup HUD
        document.getElementById('controls-stick').classList.toggle('hidden', mode === 'clash');
        document.getElementById('controls-action').classList.toggle('hidden', mode === 'clash' || mode === 'dots');
        document.getElementById('clash-ui').classList.toggle('hidden', mode !== 'clash');
        
        if(mode === 'clash') Clash.initUI();
        
        if(Net.role === 'host') Logic.init();
        Game.running = true;
        Game.loop();
    },
    loop: () => {
        if(!Game.running) return;
        requestAnimationFrame(Game.loop);
        
        if(Net.role === 'host') {
            Logic.update();
            Net.conn.send({ type: 'STATE', st: Logic.state });
            Renderer.render(Logic.state);
        } else {
            // –ö–ª–∏–µ–Ω—Ç –ø—Ä–æ—Å—Ç–æ —à–ª–µ—Ç –≤–≤–æ–¥
            if(Game.mode !== 'clash')
                Net.conn.send({ type: 'INPUT', val: Input });
            else
                Net.conn.send({ type: 'INPUT', val: { spawnIdx: Input.spawnIdx } });
            
            // –ï—Å–ª–∏ –±—ã–ª–∞ –∫–∞—Ä—Ç–æ—á–∫–∞ - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞–∂–∞—Ç–∏–µ –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
            Input.spawnIdx = null; 
        }
    },
    syncState: (state) => {
        Renderer.render(state);
    }
};

// === GAME LOGIC (HOST ONLY) ===
const Logic = {
    state: {}, p2Inp: {}, 
    
    init: () => {
        Logic.state = {
            t: 0, p1s: 0, p2s: 0, 
            ents: [], fx: [], mode: Game.mode
        };
        const s = Logic.state;

        if(Game.mode === 'tanks') {
            s.p1 = { x: 100, y: CONFIG.h/2, hp: 100, cd: 0, angle: 0 };
            s.p2 = { x: CONFIG.w-100, y: CONFIG.h/2, hp: 100, cd: 0, angle: Math.PI };
            s.map = [];
            // Generate Map
            for(let i=0; i<10; i++) 
                s.map.push({x: Math.random()*CONFIG.w, y: Math.random()*CONFIG.h, w: 30+Math.random()*50, h: 30+Math.random()*80});
        }
        else if(Game.mode === 'clash') {
             s.elixir = { p1: 5, p2: 5 };
        }
        else if(Game.mode === 'dots') {
             s.p1 = { x: 200, y: 300, r: 15 };
             s.p2 = { x: 600, y: 300, r: 15 };
             s.food = [];
        }
    },

    update: () => {
        const s = Logic.state; s.t++;
        const i1 = Input; const i2 = Logic.p2Inp;

        if(s.mode === 'tanks') Tanks.upd(s, i1, i2);
        else if(s.mode === 'clash') Clash.upd(s, i1, i2);
        else if(s.mode === 'dots') Dots.upd(s, i1, i2);

        // Physics Cleanup
        s.ents = s.ents.filter(e => e.active);
    }
};

// --- MODE: TANKS ---
const Tanks = {
    upd: (s, i1, i2) => {
        // Move
        const spd = 4;
        [ {p:s.p1, i:i1}, {p:s.p2, i:i2} ].forEach((obj, idx) => {
            const p = obj.p; const inp = obj.i;
            p.x += inp.x * spd; p.y += inp.y * spd;
            if(Math.abs(inp.ax)+Math.abs(inp.ay) > 0.1) 
                p.angle = Math.atan2(inp.ay, inp.ax);
            
            // Walls Collide
            p.x = Math.max(0, Math.min(CONFIG.w, p.x));
            p.y = Math.max(0, Math.min(CONFIG.h, p.y));
            s.map.forEach(w => {
                 if(p.x>w.x && p.x<w.x+w.w && p.y>w.y && p.y<w.y+w.h) {
                     p.x -= inp.x*spd; p.y -= inp.y*spd;
                 }
            });

            // Shoot
            if(p.cd>0) p.cd--;
            if(inp.action && p.cd <= 0) {
                s.ents.push({
                    type: 'bull', owner: idx, 
                    x: p.x + Math.cos(p.angle)*30, y: p.y + Math.sin(p.angle)*30, 
                    vx: Math.cos(p.angle)*12, vy: Math.sin(p.angle)*12, active:true
                });
                p.cd = 15;
            }
        });

        // Bullets
        s.ents.forEach(b => {
            b.x += b.vx; b.y += b.vy;
            if(b.x<0||b.x>CONFIG.w||b.y<0||b.y>CONFIG.h) b.active=false;
            // Hit Map
            s.map.forEach(w => {
                if(b.x>w.x && b.x<w.x+w.w && b.y>w.y && b.y<w.y+w.h) { b.active=false; }
            });
            // Hit Player
            let enemy = b.owner===0 ? s.p2 : s.p1;
            if(Math.hypot(b.x-enemy.x, b.y-enemy.y) < 25) {
                b.active = false;
                s[b.owner===0?'p1s':'p2s']++;
                enemy.x = Math.random()*CONFIG.w; enemy.y = Math.random()*CONFIG.h; // Respawn
            }
        });
    }
};

// --- MODE: CLASH ---
const CARDS = [
    { name: 'WAR', hp: 50, spd: 2, c: 2, dmg: 1, type: 'a' },
    { name: 'TANK', hp: 150, spd: 1, c: 4, dmg: 2, type: 'b' },
    { name: 'FAST', hp: 30, spd: 5, c: 2, dmg: 3, type: 'c' }
];

const Clash = {
    initUI: () => {
        const d = document.getElementById('card-dock'); d.innerHTML = '';
        CARDS.forEach((c, idx) => {
            let el = document.createElement('div');
            el.className = 'card';
            el.innerHTML = `<div class="cost-bubble">${c.c}</div><div>${c.name}</div>`;
            el.ontouchstart = () => { Input.spawnIdx = idx; }; 
            // –¥–ª—è –º—ã—à–∏ —Ç–æ–∂–µ
            el.onmousedown = () => { Input.spawnIdx = idx; };
            d.appendChild(el);
        });
    },
    upd: (s, i1, i2) => {
        if(s.t % 60 === 0) { // +1 Elixir/sec
            if(s.elixir.p1 < 10) s.elixir.p1++;
            if(s.elixir.p2 < 10) s.elixir.p2++;
        }

        // Spawn logic
        const spawn = (owner, idx) => {
            if(idx === null || idx === undefined) return;
            const unit = CARDS[idx];
            const pEl = owner===0?s.elixir.p1:s.elixir.p2;
            if(pEl >= unit.c) {
                s.ents.push({
                    type:'unit', owner:owner, max: unit.hp, hp: unit.hp, 
                    spd: unit.spd, dmg: unit.dmg, active:true,
                    x: owner===0 ? 40 : CONFIG.w-40,
                    y: 100 + Math.random()*(CONFIG.h-200)
                });
                if(owner===0) s.elixir.p1 -= unit.c; else s.elixir.p2 -= unit.c;
            }
        };

        if(i1 && i1.spawnIdx!==null) { spawn(0, i1.spawnIdx); i1.spawnIdx = null; }
        if(i2 && i2.spawnIdx!==null) { spawn(1, i2.spawnIdx); Logic.p2Inp.spawnIdx = null; }

        // Logic
        s.ents.forEach(u => {
            // Find target
            let target = null; let minD = 200;
            s.ents.forEach(e => {
                if(e.owner !== u.owner) {
                    let d = Math.hypot(u.x-e.x, u.y-e.y);
                    if(d < minD) { minD = d; target = e; }
                }
            });

            if(target && minD < 30) {
                if(s.t%20===0) target.hp -= u.dmg;
            } else {
                if(target) { // move to target
                     let a = Math.atan2(target.y-u.y, target.x-u.x);
                     u.x += Math.cos(a)*u.spd; u.y += Math.sin(a)*u.spd;
                } else { // forward
                     u.x += (u.owner===0 ? 1 : -1) * u.spd;
                }
            }
            if(u.hp<=0) u.active=false;
            if(u.x<0 || u.x>CONFIG.w) {
                u.active = false;
                if(u.owner===0) s.p1s++; else s.p2s++;
            }
        });
    }
};

// --- MODE: DOTS ---
const Dots = {
    upd: (s, i1, i2) => {
        const move = (p, i) => { 
            p.x+=i.x*4; p.y+=i.y*4; 
            if(p.x<0)p.x=0; if(p.y<0)p.y=0;
        };
        move(s.p1, i1); move(s.p2, i2 || {x:0,y:0});

        // Food gen
        if(s.t % 30 === 0 && s.food.length < 50) 
            s.food.push({x:Math.random()*CONFIG.w, y:Math.random()*CONFIG.h, active:true});

        // Eat
        const check = (p, idx) => {
            s.food.forEach(f => {
                if(f.active && Math.hypot(p.x-f.x, p.y-f.y) < p.r) {
                    f.active = false;
                    p.r += 0.5;
                    s[idx===0?'p1s':'p2s']++;
                }
            });
        };
        check(s.p1, 0); check(s.p2, 1);
        s.food = s.food.filter(f=>f.active);

        // Win
        if(s.p1.r > s.p2.r && Math.hypot(s.p1.x-s.p2.x, s.p1.y-s.p2.y) < s.p1.r) s.p1s+=5;
    }
}


// === RENDERER ===
const Renderer = {
    render: (s) => {
        if(!s) return;
        const ctx = Game.ctx;
        ctx.fillStyle = '#050510'; ctx.fillRect(0,0,CONFIG.w, CONFIG.h);

        // Grid bg
        ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1;
        for(let i=0; i<CONFIG.w; i+=50) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,CONFIG.h); ctx.stroke(); }

        // HUD Text Update
        document.getElementById('s1').innerText = s.p1s;
        document.getElementById('s2').innerText = s.p2s;

        if(s.mode === 'tanks') {
            // Walls
            ctx.fillStyle = '#445'; 
            ctx.shadowBlur=10; ctx.shadowColor='#000';
            s.map.forEach(w => ctx.fillRect(w.x, w.y, w.w, w.h));
            ctx.shadowBlur=0;
            
            // Tanks
            Renderer.tank(s.p1, CONFIG.c.p1);
            Renderer.tank(s.p2, CONFIG.c.p2);
            
            // Bullets
            ctx.fillStyle='#fff';
            s.ents.forEach(b => {
                ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, 7); ctx.fill();
            });
        }
        else if(s.mode === 'clash') {
            ctx.beginPath(); ctx.strokeStyle='#333'; ctx.moveTo(CONFIG.w/2, 0); ctx.lineTo(CONFIG.w/2, CONFIG.h); ctx.stroke();
            
            s.ents.forEach(u => {
                const c = u.owner===0 ? CONFIG.c.p1 : CONFIG.c.p2;
                ctx.fillStyle = c; ctx.shadowBlur=10; ctx.shadowColor=c;
                ctx.beginPath(); ctx.arc(u.x, u.y, 10 + (u.hp/50), 0, 7); ctx.fill();
            });
            ctx.shadowBlur=0;

            if(document.getElementById('elixir-fill')) {
                const me = Net.role==='host'?s.elixir.p1:s.elixir.p2;
                document.getElementById('elixir-fill').style.height = (me*10)+'%';
            }
        }
        else if(s.mode === 'dots') {
            ctx.fillStyle='gold';
            s.food.forEach(f => { ctx.fillRect(f.x-2, f.y-2, 4, 4); });
            ctx.globalAlpha=0.8;
            ctx.fillStyle=CONFIG.c.p1; ctx.beginPath(); ctx.arc(s.p1.x, s.p1.y, s.p1.r, 0, 7); ctx.fill();
            ctx.fillStyle=CONFIG.c.p2; ctx.beginPath(); ctx.arc(s.p2.x, s.p2.y, s.p2.r, 0, 7); ctx.fill();
            ctx.globalAlpha=1;
        }
    },
    tank: (t, c) => {
        const ctx = Game.ctx;
        ctx.translate(t.x, t.y);
        ctx.rotate(t.angle);
        ctx.fillStyle = c;
        ctx.shadowBlur=15; ctx.shadowColor=c;
        ctx.fillRect(-20, -15, 30, 30); // body
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, -5, 40, 10); // gun
        ctx.shadowBlur=0;
        ctx.rotate(-t.angle);
        ctx.translate(-t.x, -t.y);
    }
};

// === INPUT SYSTEM (JOYSTICKS) ===
const Joy = {
    setup: (id, cb) => {
        const zone = document.getElementById(id);
        const stick = zone.querySelector('.joystick-stick');
        let drag=false, start={x:0,y:0}, r=50;

        const move = (cx, cy) => {
            let dx = cx - start.x, dy = cy - start.y;
            const dist = Math.min(Math.hypot(dx,dy), r);
            const ang = Math.atan2(dy, dx);
            const ox = Math.cos(ang)*dist, oy = Math.sin(ang)*dist;
            stick.style.transform = `translate(${ox}px, ${oy}px)`;
            cb(ox/r, oy/r);
        };

        zone.addEventListener('touchstart', e => {
            drag=true; const b=zone.getBoundingClientRect(); 
            start = {x: b.left+60, y: b.top+60};
            move(e.touches[0].clientX, e.touches[0].clientY);
            if(id === 'joy-act') Input.action = true;
        });
        zone.addEventListener('touchmove', e => {
            if(drag) { e.preventDefault(); move(e.touches[0].clientX, e.touches[0].clientY); }
        });
        zone.addEventListener('touchend', () => {
            drag=false; stick.style.transform = `translate(0,0)`; cb(0,0);
            if(id === 'joy-act') Input.action = false;
        });
        
        // PC Mouse support (–¥–ª—è —Ç–µ—Å—Ç–æ–≤)
        zone.onmousedown = (e) => {
             drag=true; const b=zone.getBoundingClientRect(); start = {x: b.left+60, y: b.top+60};
             if(id === 'joy-act') Input.action = true;
        };
        window.onmousemove = (e) => { if(drag) move(e.clientX, e.clientY); };
        window.onmouseup = () => { if(drag) {drag=false; stick.style.transform='translate(0,0)'; cb(0,0); Input.action=false;} };
    }
};

Joy.setup('joy-move', (x,y) => { Input.x=x; Input.y=y; });
Joy.setup('joy-act', (x,y) => { Input.ax=x; Input.ay=y; });

// --- UTILS ---
const UI = {
    show: (id) => {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        const el = document.getElementById(id);
        el.classList.remove('hidden');
        if(id === 'scr-game') el.style.display = 'block';
    }
}
</script>
</body>
</html>
